I"S<p>开发当中难免会遇到跨域相关的问题，这其中牵涉到很多知识，好好理解并消化这部分知识大有裨益。</p>

<h4 id="简介">简介</h4>

<p>跨域：浏览器对于javascript的同源策略的限制 。</p>

<p>以下情况都属于跨域：</p>

<table>
  <thead>
    <tr>
      <th>跨域原因说明</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>域名不同</td>
      <td><code class="highlighter-rouge">www.jd.com</code> 与 <code class="highlighter-rouge">www.taobao.com</code></td>
    </tr>
    <tr>
      <td>域名相同，端口不同</td>
      <td><code class="highlighter-rouge">www.jd.com:8080</code> 与 <code class="highlighter-rouge">www.jd.com:8081</code></td>
    </tr>
    <tr>
      <td>二级域名不同</td>
      <td><code class="highlighter-rouge">item.jd.com</code> 与 <code class="highlighter-rouge">miaosha.jd.com</code></td>
    </tr>
  </tbody>
</table>

<p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p>

<p><code class="highlighter-rouge">www.jd.com/item</code></p>

<p><code class="highlighter-rouge">www.jd.com/goods</code></p>

<p>而我们刚才是从<code class="highlighter-rouge">manage.leyou.com</code>去访问<code class="highlighter-rouge">api.leyou.com</code>，这属于二级域名不同，跨域了。</p>

<h4 id="为什么会有跨域问题">为什么会有跨域问题</h4>

<p>跨域不一定会有跨域问题。</p>

<p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是与当前页域名相同的路径</strong>，这能有效的阻止跨站攻击。</p>

<p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p>

<p>但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p>

<h4 id="跨域问题的可选解决方案">跨域问题的可选解决方案</h4>

<p>目前比较常用的跨域解决方案有3种：</p>

<ul>
  <li>
    <p>Jsonp</p>

    <p>最早的解决方案，利用script标签可以跨域的原理实现。</p>

    <p>限制：</p>

    <ul>
      <li>需要服务的支持</li>
      <li>只能发起GET请求</li>
    </ul>
  </li>
  <li>
    <p>nginx反向代理</p>

    <p>思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式</p>

    <p>缺点：需要在nginx进行额外配置，语义不清晰</p>
  </li>
  <li>
    <p>CORS</p>

    <p>规范化的跨域请求解决方案，安全可靠。</p>

    <p>优势：</p>

    <ul>
      <li>在服务端进行控制是否允许跨域，可自定义规则</li>
      <li>支持各种请求方式</li>
    </ul>

    <p>缺点：</p>

    <ul>
      <li>会产生额外的请求</li>
    </ul>
  </li>
</ul>

<p>在我的这个案例当中会采用<strong>cors的跨域方案</strong>。</p>

<h4 id="cors解决跨域">cors解决跨域</h4>

<h5 id="什么是cors">什么是cors</h5>

<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>

<p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code class="highlighter-rouge">XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>

<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>

<ul>
  <li>
    <p>浏览器端：</p>

    <p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p>
  </li>
  <li>
    <p>服务端：</p>

    <p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p>
  </li>
</ul>

<h5 id="原理有些复杂">原理有些复杂</h5>

<p>浏览器会将ajax请求分为两类，其处理方案略有差异：<strong>简单请求、特殊请求。</strong></p>

<ul>
  <li><strong>简单请求</strong></li>
</ul>

<p>只要同时满足以下两大条件，就属于简单请求。：</p>

<p>（1) 请求方法是以下三种方法之一：</p>

<ul>
  <li>HEAD</li>
  <li>GET</li>
  <li>POST</li>
</ul>

<p>（2）HTTP的头信息不超出以下几种字段：</p>

<ul>
  <li>Accept</li>
  <li>Accept-Language</li>
  <li>Content-Language</li>
  <li>Last-Event-ID</li>
  <li>Content-Type：只限于三个值<code class="highlighter-rouge">application/x-www-form-urlencoded</code>、<code class="highlighter-rouge">multipart/form-data</code>、<code class="highlighter-rouge">text/plain</code></li>
</ul>

<p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：<code class="highlighter-rouge">Origin</code>.</p>

<p><img src="http://image.augustrush8.com/images/1530460311064.png" alt="" class="center" /></p>

<p>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p>

<p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Access-Control-Allow-Origin: http://manage.leyou.com
Access-Control-Allow-Credentials: true
Content-Type: text/html; charset=utf-8
</span></code></pre></div></div>

<ul>
  <li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li>
  <li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li>
</ul>

<blockquote>
  <p>有关cookie：</p>
</blockquote>

<p>要想操作cookie，需要满足3个条件：</p>

<ul>
  <li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li>
  <li>浏览器发起ajax需要指定withCredentials 为true</li>
  <li>
    <p>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</p>
  </li>
  <li><strong>特殊请求</strong></li>
</ul>

<p>不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。</p>

<blockquote>
  <p>预检请求</p>
</blockquote>

<p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>

<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code class="highlighter-rouge">XMLHttpRequest</code>请求，否则就报错。</p>

<p>一个“预检”请求的样板：</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">OPTIONS</span> <span class="nn">/cors</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Origin</span><span class="p">:</span> <span class="s">http://manage.leyou.com</span>
<span class="na">Access-Control-Request-Method</span><span class="p">:</span> <span class="s">PUT</span>
<span class="na">Access-Control-Request-Headers</span><span class="p">:</span> <span class="s">X-Custom-Header</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">api.leyou.com</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0...</span>
</code></pre></div></div>

<p>与简单请求相比，除了Origin以外，多了两个头：</p>

<ul>
  <li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li>
  <li>Access-Control-Request-Headers：会额外用到的头信息</li>
</ul>

<blockquote>
  <p>预检请求的响应</p>
</blockquote>

<p>服务的收到预检请求，如果许可跨域，会发出响应：</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Mon, 01 Dec 2008 01:15:39 GMT</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Apache/2.0.61 (Unix)</span>
<span class="na">Access-Control-Allow-Origin</span><span class="p">:</span> <span class="s">http://manage.leyou.com</span>
<span class="na">Access-Control-Allow-Credentials</span><span class="p">:</span> <span class="s">true</span>
<span class="na">Access-Control-Allow-Methods</span><span class="p">:</span> <span class="s">GET, POST, PUT</span>
<span class="na">Access-Control-Allow-Headers</span><span class="p">:</span> <span class="s">X-Custom-Header</span>
<span class="na">Access-Control-Max-Age</span><span class="p">:</span> <span class="s">1728000</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=utf-8</span>
<span class="na">Content-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Keep-Alive</span><span class="p">:</span> <span class="s">timeout=2, max=100</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Keep-Alive</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/plain</span>
</code></pre></div></div>

<p>除了<code class="highlighter-rouge">Access-Control-Allow-Origin</code>和<code class="highlighter-rouge">Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p>

<ul>
  <li>Access-Control-Allow-Methods：允许访问的方式</li>
  <li>Access-Control-Allow-Headers：允许携带的头</li>
  <li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li>
</ul>

<p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p>

<h5 id="实现非常简单">实现非常简单</h5>

<p>虽然原理比较复杂，但是前面说过：</p>

<ul>
  <li>浏览器端都有浏览器自动完成，我们无需操心</li>
  <li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li>
</ul>

<p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p>

<p>在<code class="highlighter-rouge">leyou-gateway</code>中编写一个配置类，并且注册CorsFilter。</p>

<p>描述一下我的项目结构和请求流程：</p>

<ul>
  <li>项目结构</li>
</ul>

<p><img src="http://image.augustrush8.com/images/project.png" alt="" class="center" /></p>

<ul>
  <li>请求流程</li>
</ul>

<p><img src="http://image.augustrush8.com/images/structure.png" alt="" class="center" /></p>

<p>前台发起访问<code class="highlighter-rouge">http://api.leyou.com/api/item/category/list?pid=0</code></p>

<p>经过nginx，判断资源定向</p>

<p><img src="http://image.augustrush8.com/images/corsNginxConfig.png" alt="" class="center" /></p>

<p>于是发送给<code class="highlighter-rouge">ly-api-gateway</code>去处理，这个时候就需要在<code class="highlighter-rouge">ly-api-gateway</code>当中配置<code class="highlighter-rouge">CorsFilter</code>了，由于是<code class="highlighter-rouge">http://manage.leyou.com</code>发送到<code class="highlighter-rouge">api.leyou.com</code>,这就涉及到服务端对特定域下的资源请求是否通过了，我们在下面代码当中添加了允许的域：<code class="highlighter-rouge">configuration.addAllowedOrigin("http://manage.leyou.com");</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalCorsConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CorsFilter</span> <span class="nf">corsFilter</span><span class="o">(){</span>
        <span class="c1">//添加cors配置信息</span>
        <span class="nc">CorsConfiguration</span> <span class="n">configuration</span><span class="o">=</span><span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>
        <span class="c1">//1) 允许的域,不要写*，否则cookie就无法使用了</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedOrigin</span><span class="o">(</span><span class="s">"http://manage.leyou.com"</span><span class="o">);</span>
        <span class="c1">//2) 是否发送Cookie信息</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowCredentials</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="c1">//3) 允许的请求方式</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"OPTIONS"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"HEAD"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"GET"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"PUT"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"POST"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"DELETE"</span><span class="o">);</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedMethod</span><span class="o">(</span><span class="s">"PATCH"</span><span class="o">);</span>
        <span class="c1">// 4）允许的头信息</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">addAllowedHeader</span><span class="o">(</span><span class="s">"*"</span><span class="o">);</span>
        <span class="c1">//2.添加映射路径，我们拦截一切请求</span>
        <span class="nc">UrlBasedCorsConfigurationSource</span> <span class="n">configurationSource</span><span class="o">=</span><span class="k">new</span> <span class="nc">UrlBasedCorsConfigurationSource</span><span class="o">();</span>
        <span class="n">configurationSource</span><span class="o">.</span><span class="na">registerCorsConfiguration</span><span class="o">(</span><span class="s">"/**"</span><span class="o">,</span><span class="n">configuration</span><span class="o">);</span>
        <span class="c1">//返回新的corsFilter</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">CorsFilter</span><span class="o">(</span><span class="n">configurationSource</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>紧接着网关识别出当前资源请求域是<code class="highlighter-rouge">http://manage.leyou.com</code>,于是给予处理，发现匹配模式<code class="highlighter-rouge">/api</code>,与自己配置文件吻合,于是路由到<code class="highlighter-rouge">item-service</code>这个微服务去处理。</p>

<p><img src="http://image.augustrush8.com/images/corsZuulConfig.png" alt="" class="center" /></p>

<p>最后即是在<code class="highlighter-rouge">item-service</code>当中做处理并返回结果</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"category"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CategoryController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nc">CategoryService</span> <span class="n">categoryService</span><span class="o">;</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"list"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Category</span><span class="o">&gt;&gt;</span> <span class="nf">queryCategoryListByParentId</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"pid"</span><span class="o">,</span><span class="n">defaultValue</span> <span class="o">=</span> <span class="s">"0"</span><span class="o">)</span><span class="nc">Long</span> <span class="n">pid</span><span class="o">){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pid</span><span class="o">==</span><span class="kc">null</span><span class="o">||</span><span class="n">pid</span><span class="o">.</span><span class="na">longValue</span><span class="o">()&lt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="c1">// pid为null或者小于等于0，响应400</span>
                <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">badRequest</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">//执行查询操作</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Category</span><span class="o">&gt;</span> <span class="n">categoryList</span><span class="o">=</span><span class="k">this</span><span class="o">.</span><span class="na">categoryService</span><span class="o">.</span><span class="na">queryCategoryListByParentId</span><span class="o">(</span><span class="n">pid</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">categoryList</span><span class="o">==</span><span class="kc">null</span><span class="o">||</span><span class="n">categoryList</span><span class="o">.</span><span class="na">size</span><span class="o">()&lt;</span><span class="mi">1</span><span class="o">){</span>
                <span class="c1">// 返回结果集为空，响应404</span>
                <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">notFound</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">//响应200</span>
            <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">categoryList</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">//以上都不是，响应500</span>
        <span class="k">return</span>  <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">INTERNAL_SERVER_ERROR</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h4 id="测试">测试</h4>

<p>这里自己犯二了，之前明显配置的是允许<code class="highlighter-rouge">http://manage.leyou.com</code>域的请求，而自己在启动Vue后台项目之后，使用它的默认配置请求地址<code class="highlighter-rouge"> http://localhost:9001</code>，请求发现还是跨域的问题，检查两遍后改了请求域名就好了。</p>

<p><img src="http://image.augustrush8.com/images/corstest.png" alt="" class="center" /></p>
:ET