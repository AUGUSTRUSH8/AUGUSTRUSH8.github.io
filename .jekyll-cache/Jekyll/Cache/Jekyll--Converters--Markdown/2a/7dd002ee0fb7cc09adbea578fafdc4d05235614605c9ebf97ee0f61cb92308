I"<p>现有如下代码,那么我们的JVM是怎么执行的呢</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="n">vodi</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
          <span class="nc">MaYun</span> <span class="n">my</span><span class="o">=</span><span class="k">new</span> <span class="nc">MaYun</span><span class="o">();</span>
          <span class="n">my</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
    <span class="o">}</span>      
<span class="o">}</span>  


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaYun</span><span class="o">{</span>
     
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">(){</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"i am working"</span><span class="o">)</span>
        <span class="o">}</span>
<span class="o">}</span>          
</code></pre></div></div>

<p>首先，当启动虚拟机进程后首先从classpath中找到Test.class文件，读取这个文件中的二进制数据，然后把Test类的类信息存放到运行时数据区的方法区中。这一过程称为Test类的加载过程。</p>

<p>接着，Java虚拟机定位到方法区中Test类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MaYun</span> <span class="n">my</span><span class="o">=</span><span class="k">new</span> <span class="nc">MaYun</span><span class="o">();</span>
</code></pre></div></div>

<p>语句很简单，就是让java虚拟机创建一个MaYun 实例，并且使引用变量my引用这个实例。来跟踪一下Java虚拟机，看看它究竟是怎么来执行这个任务的：</p>

<ol>
  <li>Java虚拟机一看，不就是建立一个MaYun 实例吗，简单，于是就直<strong>奔方法区而去，先找到MuYun类的类型信息</strong>再说。结果呢，嘿嘿，没找到， 这会儿的方法区里还没有MaYun 类呢。可Java虚拟机也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马<strong>加载了MaYun 类， 把MaYun 类的类型信息存放在方法区里</strong>。</li>
  <li>好啦，资料找到了，下面就开始干活了。Java虚拟机做的第一件事情就是在堆区中为一个新的MaYun 实例<strong>分配内存</strong>, 这个<strong>MaYun 实例持有着指向方法区的MaYun 类的类型信息的引用</strong>。这里所说的引用，实际上指的是MaYun 类的类型信息在方法区中的内存地址， 其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就<strong>存放了在MaYun 实例的数据区里</strong>。</li>
  <li>在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方 法的时候就会向方法栈压入一个新帧。<strong>这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据</strong>。OK，原理讲完了，就让我们来继续我们的跟踪行动,位 于“=”前的my是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，它会被添加到执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个my变量指向堆区中的MaYun 实例，也就是说，它持有指向MaYun 实例的引用。</li>
</ol>

<p>OK，到这里为止呢，JAVA虚拟机就完成了这个简单语句的执行任务。参考我们的行动向导图，我们终于初步摸清了JAVA虚拟机的一点点底细了</p>

<p>接下来，JAVA虚拟机将继续执行后续指令，然后依次执行它们的work()方法。当JAVA虚拟机 执行my.work()方法时，JAVA虚拟机根据局部变量my持有的引用，定位到堆区中的MaYun 实例，再根据MaYun 实例持有的引用，定位到方法去中MaYun 类的类型信息，从而获得work()方法的字节码，接着执行work()方法包含的指令。该指令被OS识别后打印到控制台就完成了他的操作了。</p>
:ET