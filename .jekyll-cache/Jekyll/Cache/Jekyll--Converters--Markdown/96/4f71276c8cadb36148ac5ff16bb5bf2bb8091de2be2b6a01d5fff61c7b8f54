I"O<h2 id="spu和sku">SPU和SKU</h2>

<p>SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集</p>

<p>SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品</p>

<p>以图为例来看：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526085541996.png" alt="1526085541996" class="center" /></p>

<ul>
  <li>本页的 华为Mate10 就是一个商品集（SPU）</li>
  <li>因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU）</li>
</ul>

<p>可以看出：</p>

<ul>
  <li>SPU是一个抽象的商品集概念，为了方便后台的管理。</li>
  <li>SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU</li>
</ul>

<h2 id="数据库设计分析">数据库设计分析</h2>

<h3 id="思考并发现问题">思考并发现问题</h3>

<p>弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。</p>

<p>首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id:主键
title：标题
description：描述
specification：规格
packaging_list：包装
after_service：售后服务
comment：评价
category_id：商品分类
brand_id：品牌
</code></pre></div></div>

<p>似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526086539789.png" alt="1526086539789" class="center" /></p>

<p>不同商品的规格不一定相同，数据库中要如何保存？</p>

<p>再看下SKU，大家觉得应该有什么字段？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id：主键
spu_id：关联的spu
price：价格
images：图片
stock：库存
颜色？
内存？
硬盘？
</code></pre></div></div>

<p>碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？</p>

<h3 id="分析规格参数">分析规格参数</h3>

<p>仔细查看每一种商品的规格你会发现：</p>

<p>虽然商品规格千变万化，但是同一类商品（如手机）的规格是统一的，有图为证：</p>

<blockquote>
  <p>华为的规格：</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526087063700.png" alt="1526087063700" class="center" /></p>

<blockquote>
  <p>三星的规格：</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526087142454.png" alt="1526087142454" class="center" /></p>

<p>也就是说，商品的规格参数应该是与分类绑定的。<strong>每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同</strong>。</p>

<p>如下图所示：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526088168565.png" alt="1526088168565" class="center" /></p>

<h3 id="sku的特有属性">SKU的特有属性</h3>

<p>SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。</p>

<p>不同种类的商品，一个手机，一个衣服，其SKU属性不相同。</p>

<p>同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。</p>

<p>这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，<strong>SKU的特有属性是商品规格参数的一部分</strong>：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526088981953.png" alt="1526088981953" class="center" /></p>

<p>也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分：</p>

<ul>
  <li>所有sku共享的规格属性（称为全局属性）</li>
  <li>每个sku不同的规格属性（称为特有属性）</li>
</ul>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526089506566.png" alt="1526089506566" class="center" /></p>

<h3 id="搜索属性">搜索属性</h3>

<p>打开一个搜索页，我们来看看过滤的条件：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526090072535.png" alt="1526090072535" class="center" /></p>

<p>你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526090228171.png" alt="1526090228171" class="center" /></p>

<p>也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。要注意的是，无论是SPU的全局属性，还是SKU的特有属性，都有可能作为搜索过滤条件的，并不冲突，而是有一个交集：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526091216124.png" alt="1526091216124" class="center" /></p>

<h2 id="规格参数表">规格参数表</h2>

<h3 id="表结构">表结构</h3>

<p>先看下规格参数表：</p>

<pre><code class="language-mysql">CREATE TABLE `tb_specification` (
  `category_id` bigint(20) NOT NULL COMMENT '规格模板所属商品分类id',
  `specifications` varchar(3000) NOT NULL DEFAULT '' COMMENT '规格参数模板，json格式',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品规格参数模板，json格式。';
</code></pre>

<p>很奇怪是吧，只有两个字段。特别需要注意的是第二个字段：</p>

<ul>
  <li>specificatons：规格参数模板，json格式</li>
</ul>

<p>为什么是一个json？我们看下规格参数的格式：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526092179381.png" alt="1526092179381" class="center" /></p>

<p>如果按照传统数据库设计，这里至少需要3张表：</p>

<ul>
  <li>group：代表组，与商品分类关联</li>
  <li>param_key：属性名，与组关联，一对多</li>
  <li>param_value：属性备选值，与属性名关联，一对多</li>
</ul>

<p>这样程序的复杂度大大增加，但是提高了数据的复用性。</p>

<p>这里的解决方案是，采用json来保存整个规格参数模板，不需要额外的表，一个字符串就够了。</p>

<h3 id="json结构分析">json结构分析</h3>

<blockquote>
  <p>先整体看一下：</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526092693138.png" alt="1526092693138" class="center" /></p>

<ul>
  <li>因为规格参数分为很多组，所以json最外层是一个数组。</li>
  <li>数组中是对象类型，每个对象代表一个组的数据，对象的属性包括：
    <ul>
      <li>group：组的名称</li>
      <li>params：该组的所有属性</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>接下来是params：</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526093111370.png" alt="1526093111370" class="center" /></p>

<p>以<code class="highlighter-rouge">主芯片</code>这一组为例：</p>

<ul>
  <li>group：注明，这里是主芯片</li>
  <li>params：该组的所有规格属性，因为不止一个，所以是一个数组。这里包含四个规格属性：CPU品牌，CPU型号，CPU频率，CPU核数。每个规格属性都是一个对象，包含以下信息：
    <ul>
      <li>k：属性名称</li>
      <li>searchable：是否作为搜索字段，将来在搜索页面使用，boolean类型</li>
      <li>global：是否是SPU全局属性，boolean类型。true为全局属性，false为SKU的特有属性</li>
      <li>options：属性值的可选项，数组结构。起约束作用，不允许填写可选项以外的值，比如CPU核数，有人添10000核岂不是很扯淡</li>
      <li>numerical：是否为数值，boolean类型，true则为数值，false则不是。为空也代表非数值</li>
      <li>unit：单位，如：克，毫米。如果是数值类型，那么就需要有单位，否则可以不填。</li>
    </ul>
  </li>
</ul>

<p>上面的截图中所有属性都是全局属性，我们来看看内存，应该是特有属性：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526262641446.png" alt="1526262641446" class="center" /></p>

<p>总结下：</p>

<ul>
  <li>规格参数分组，每组有多个参数</li>
  <li>参数的 <code class="highlighter-rouge">k</code>代表属性名称，没有值，具体的SPU才能确定值</li>
  <li>参数会有不同的属性：是否可搜索，是否是全局、是否是数值，这些都用boolean值进行标记：
    <ul>
      <li>SPU下的多个SKU共享的参数称为全局属性，用<code class="highlighter-rouge">global</code>标记</li>
      <li>SPU下的多个SKU特有的参数称为特有属性</li>
      <li>如果参数是数值类型，用<code class="highlighter-rouge">numerical</code>标记，并且指定单位<code class="highlighter-rouge">unit</code></li>
      <li>如果参数可搜索，用<code class="highlighter-rouge">searchable</code>标记</li>
    </ul>
  </li>
</ul>

<h1 id="spu和sku数据结构">SPU和SKU数据结构</h1>

<p>规格确定以后，就可以添加商品了,先看下数据库表</p>

<h2 id="spu表">SPU表</h2>

<h3 id="表结构-1">表结构</h3>

<p>SPU表：</p>

<pre><code class="language-mysql">CREATE TABLE `tb_spu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'spu id',
  `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
  `sub_title` varchar(255) DEFAULT '' COMMENT '子标题',
  `cid1` bigint(20) NOT NULL COMMENT '1级类目id',
  `cid2` bigint(20) NOT NULL COMMENT '2级类目id',
  `cid3` bigint(20) NOT NULL COMMENT '3级类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '商品所属品牌id',
  `saleable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否上架，0下架，1上架',
  `valid` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0已删除，1有效',
  `create_time` datetime DEFAULT NULL COMMENT '添加时间',
  `last_update_time` datetime DEFAULT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT='spu表，该表描述的是一个抽象的商品，比如 iphone8';
</code></pre>

<p>与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。</p>

<p>我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail</p>

<pre><code class="language-mysql">CREATE TABLE `tb_spu_detail` (
  `spu_id` bigint(20) NOT NULL,
  `description` text COMMENT '商品描述信息',
  `specifications` varchar(3000) NOT NULL DEFAULT '' COMMENT '全部规格参数数据',
  `spec_template` varchar(1000) NOT NULL COMMENT '特有规格参数及可选值信息，json格式',
  `packing_list` varchar(1000) DEFAULT '' COMMENT '包装清单',
  `after_service` varchar(1000) DEFAULT '' COMMENT '售后服务',
  PRIMARY KEY (`spu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

</code></pre>

<p>这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。</p>

<p>需要注意的是这两个字段：specifications和spec_template。</p>

<h3 id="spu中的规格参数">spu中的规格参数</h3>

<p>前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样：</p>

<ul>
  <li>SPU中保存全局的规格参数信息。</li>
  <li>SKU中保存特有规格参数。</li>
</ul>

<p>以手机为例，品牌、操作系统等肯定是全局属性，内存、颜色等肯定是特有属性。</p>

<p>当你确定了一个SPU，比如小米的：红米4X</p>

<p>全局属性举例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>品牌：小米
型号：红米4X
</code></pre></div></div>

<p>特有属性举例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>颜色：[香槟金, 樱花粉, 磨砂黑]
内存：[2G, 3G]
机身存储：[16GB, 32GB]
</code></pre></div></div>

<p>来看下我们的 表如何存储这些信息：</p>

<h4 id="specifications字段">specifications字段</h4>

<p>首先是specifications，其中保存全部规格参数信息，因此也是一个json格式：</p>

<blockquote>
  <p>整体来看：</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526262279963.png" alt="1526262279963" class="center" /></p>

<p>整体看上去与规格参数表中的数据一样，也是一个数组，并且分组，每组下有多个参数</p>

<blockquote>
  <p>展开一组来看</p>
</blockquote>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526262389233.png" alt="1526262389233" class="center" /></p>

<p>可以看到，与规格参数表中的模板相比，最大的区别就是，这里指定了具体的值，因为商品确定了，其参数值肯定也确定了。</p>

<blockquote>
  <p>特有属性</p>
</blockquote>

<p>刚才看到的是全局属性，那么特有属性在这个字段中如何存储呢？</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526263214087.png" alt="1526263214087" class="center" /></p>

<p>我们发现特有属性也是有的，但是，注意看这里是不确定具体值的，因为特有属性只有在SKU中才能确定。这里只是保存了options，所有SKU属性的可选项。</p>

<p>在哪里会用到这个字段的值呢，商品详情页的规格参数信息中：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526267700765.png" alt="1526267700765" class="center" /></p>

<h4 id="spec_template字段">spec_template字段</h4>

<p>既然specifications已经包含了所有的规格参数，那么为什么又多出了一个spec_template呢？</p>

<p>里面又有哪些内容呢？</p>

<p>来看数据格式：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526267952827.png" alt="1526267952827" class="center" /></p>

<p>可以看出，里面只保存了规格参数中的特有属性，而且格式进行了大大的简化，只有属性的key，和待选项。</p>

<p>为什么要冗余保存一份？</p>

<p>因为很多场景下我们只需要查询特有规格属性，如果放在一起，每次查询再去分离比较麻烦。</p>

<p>比如，商品详情页展示可选的规格参数时：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526267828817.png" alt="1526267828817" class="center" /></p>

<h2 id="sku表">SKU表</h2>

<h3 id="表结构-2">表结构</h3>

<pre><code class="language-mysql">CREATE TABLE `tb_sku` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'sku id',
  `spu_id` bigint(20) NOT NULL COMMENT 'spu id',
  `title` varchar(255) NOT NULL COMMENT '商品标题',
  `images` varchar(1000) DEFAULT '' COMMENT '商品的图片，多个图片以‘,’分割',
  `price` bigint(15) NOT NULL DEFAULT '0' COMMENT '销售价格，单位为分',
  `indexes` varchar(100) COMMENT '特有规格属性在spu属性模板中的对应下标组合',
  `own_spec` varchar(1000) COMMENT 'sku的特有规格参数，json格式，反序列化时应使用linkedHashMap，保证有序',
  `enable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0无效，1有效',
  `create_time` datetime NOT NULL COMMENT '添加时间',
  `last_update_time` datetime NOT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`),
  KEY `key_spu_id` (`spu_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8';
</code></pre>

<p>还有一张表，代表库存：</p>

<pre><code class="language-mysql">CREATE TABLE `tb_stock` (
  `sku_id` bigint(20) NOT NULL COMMENT '库存对应的商品sku id',
  `seckill_stock` int(9) DEFAULT '0' COMMENT '可秒杀库存',
  `seckill_total` int(9) DEFAULT '0' COMMENT '秒杀总数量',
  `stock` int(9) NOT NULL COMMENT '库存数量',
  PRIMARY KEY (`sku_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='库存表，代表库存，秒杀库存等信息';
</code></pre>

<p>问题：为什么要将库存独立一张表？</p>

<p>因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。</p>

<p>特别需要注意的是sku表中的<code class="highlighter-rouge">indexes</code>字段和<code class="highlighter-rouge">own_spec</code>字段。sku中应该保存特有规格参数的值，就在这两个字段中。</p>

<h3 id="sku中的特有规格参数">sku中的特有规格参数</h3>

<h4 id="indexes字段">indexes字段</h4>

<p>在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"机身颜色"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"香槟金"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"樱花粉"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"磨砂黑"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"内存"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"2GB"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"3GB"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"机身存储"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"16GB"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"32GB"</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。</p>

<p>比如：</p>

<ul>
  <li>红米4X，香槟金，2GB内存，16GB存储</li>
  <li>红米4X，磨砂黑，2GB内存，32GB存储</li>
</ul>

<p>你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样：</p>

<ul>
  <li>红米4X，0,0,0</li>
  <li>红米4X，2,0,1</li>
</ul>

<p>既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526266901335.png" alt="1526266901335" class="center" /></p>

<p>这个设计在商品详情页会特别有用：</p>

<p><img src="http://image.augustrush8.com/images/databaseDesign/1526267180997.png" alt="1526267180997" class="center" /></p>

<p>当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。</p>

<h4 id="own_spec字段">own_spec字段</h4>

<p>看结构：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"机身颜色"</span><span class="p">:</span><span class="s2">"香槟金"</span><span class="p">,</span><span class="nl">"内存"</span><span class="p">:</span><span class="s2">"2GB"</span><span class="p">,</span><span class="nl">"机身存储"</span><span class="p">:</span><span class="s2">"16GB"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>保存的是特有属性的键值对。</p>

<p>SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。</p>

<p>这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。</p>
:ET