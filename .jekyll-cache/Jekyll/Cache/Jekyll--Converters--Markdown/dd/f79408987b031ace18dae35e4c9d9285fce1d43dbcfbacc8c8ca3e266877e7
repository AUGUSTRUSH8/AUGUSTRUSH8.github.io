I"b<p><strong>目录索引</strong>：</p>

<ul id="markdown-toc">
  <li><a href="#java线程的创建方式" id="markdown-toc-java线程的创建方式">Java线程的创建方式</a></li>
  <li><a href="#4种线程池" id="markdown-toc-4种线程池">4种线程池</a></li>
  <li><a href="#线程生命周期" id="markdown-toc-线程生命周期">线程生命周期</a></li>
  <li><a href="#终止线程的4种方式" id="markdown-toc-终止线程的4种方式">终止线程的4种方式</a></li>
  <li><a href="#sleep-与-wait-区别" id="markdown-toc-sleep-与-wait-区别">sleep 与 wait 区别</a></li>
  <li><a href="#start-与-run-区别" id="markdown-toc-start-与-run-区别">start 与 run 区别</a></li>
  <li><a href="#java后台线程" id="markdown-toc-java后台线程">Java后台线程</a></li>
</ul>
<h3 id="java线程的创建方式">Java线程的创建方式</h3>

<ul>
  <li><strong>继承 Thread 类</strong></li>
</ul>

<p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。 启动线程的唯一方法就是通过 Thread 类的 start()实例方法。 <strong>start()方法是一个 native 方法</strong>，它将启动一个新线程，并执行 run()方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyThread.run()"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">MyThread</span> <span class="n">myThread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
<span class="n">myThread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><strong>实现 Runnable 接口</strong></li>
</ul>

<p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">OtherClass</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyThread.run()"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：</span>
<span class="nc">MyThread</span> <span class="n">myThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">myThread</span><span class="o">);</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>ExecutorService、 Callable<Class>、 Future 有返回值线程</Class></li>
</ul>

<p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//创建一个线程池</span>
<span class="nc">ExecutorService</span> <span class="n">pool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">taskSize</span><span class="o">);</span>
<span class="c1">// 创建多个有返回值的任务</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">taskSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">Callable</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyCallable</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
    <span class="c1">// 执行任务并获取 Future 对象</span>
    <span class="nc">Future</span> <span class="n">f</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 关闭线程池</span>
<span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
<span class="c1">// 获取所有并发任务的运行结果</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Future</span> <span class="n">f</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 从 Future 对象上获取任务的返回值，并输出到控制台</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"res： "</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>基于线程池的方式</li>
</ul>

<p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建线程池</span>
<span class="nc">ExecutorService</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 提交多个线程任务，并执行</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" is running .."</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="4种线程池">4种线程池</h3>

<p>Java 里面线程池的顶级接口是 <strong>Executor</strong>，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <strong>ExecutorService</strong></p>

<ul>
  <li><strong>newCachedThreadPool</strong></li>
</ul>

<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。 <strong>调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。 因此，长时间保持空闲的线程池不会使用任何资源。</p>

<ul>
  <li><strong>newFixedThreadPool</strong></li>
</ul>

<p><strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>

<ul>
  <li><strong>newScheduledThreadPool</strong></li>
</ul>

<p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">scheduledThreadPool</span><span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="n">scheduledThreadPool</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="n">newRunnable</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"延迟三秒"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
<span class="n">scheduledThreadPool</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(</span><span class="n">newRunnable</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"延迟 1 秒后每三秒执行一次"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li><strong>newSingleThreadExecutor</strong></li>
</ul>

<p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程） ,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>

<h3 id="线程生命周期">线程生命周期</h3>

<p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过<strong>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p>

<ul>
  <li><strong>新建状态（NEW）</strong></li>
</ul>

<p>当程序使用 <strong>new 关键字创建了一个线程之后</strong>，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p>

<ul>
  <li><strong>就绪状态（RUNNABLE）</strong></li>
</ul>

<p>当线程对象<strong>调用了 start()方法之后，该线程处于就绪状态</strong>。 Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>

<ul>
  <li><strong>运行状态（RUNNING）</strong></li>
</ul>

<p>如果处于<strong>就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体</strong>，则该线程处于运行状态。</p>

<ul>
  <li><strong>阻塞状态（BLOCKED）</strong></li>
</ul>

<p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种 ：</p>

<p><strong>等待阻塞（o.wait-&gt;等待对列）</strong>：运行(running)的线程执行 o.wait()方法， JVM 会把该线程放入等待队列(waitting queue)中。</p>

<p><strong>同步阻塞(lock-&gt;锁池)</strong> ：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。</p>

<p><strong>其他阻塞(sleep/join)</strong>  ：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、 join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>

<ul>
  <li>线程死亡（DEAD）</li>
</ul>

<p>线程会以下面三种方式结束，结束后就是死亡状态。</p>

<p>​	1.<strong>正常结束</strong> ：run()或 call()方法执行完成，线程正常结束。</p>

<p>​	2.<strong>异常结束</strong> ：线程抛出一个未捕获的 Exception 或 Error。</p>

<p>​	3.<strong>调用 stop</strong> ：直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p>

<p><img src="http://image.augustrush8.com/images/multiThreadState.png" alt="" /></p>

<h3 id="终止线程的4种方式">终止线程的4种方式</h3>

<ul>
  <li><strong>正常运行结束</strong></li>
</ul>

<p>程序运行结束，线程自动结束。</p>

<ul>
  <li><strong>使用退出标志退出线程</strong></li>
</ul>

<p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出，代码示例 ：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafe</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">exit</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">exit</span><span class="o">){</span>
<span class="c1">//do something</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>定义了一个退出标志 exit，当 exit 为 true 时， while 循环退出， exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。</p>

<ul>
  <li><strong>Interrupt 方法结束线程</strong></li>
</ul>

<p>使用 interrupt()方法来中断线程有两种情况：</p>

<p>1.线程处于阻塞状态： 如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。 <strong>通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</strong></p>

<p>2.线程未处于阻塞状态： 使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafe</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">()){</span> <span class="c1">//非阻塞过程中通过判断中断标志来退出</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">1000</span><span class="o">);</span><span class="c1">//阻塞过程捕获中断异常来退出</span>
            <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">){</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span><span class="c1">//捕获到异常之后，执行 break 跳出循环</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>stop 方法终止线程（线程不安全）</strong></li>
</ul>

<p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在<strong>调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</strong>，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因
此，并不推荐使用 stop 方法来终止线程。</p>

<h3 id="sleep-与-wait-区别">sleep 与 wait 区别</h3>

<ol>
  <li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的</li>
  <li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。</li>
  <li>在调用 sleep()方法的过程中， <strong>线程不会释放对象锁</strong></li>
  <li>而当<strong>调用 wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的<strong>等待锁定池</strong>，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
</ol>

<h3 id="start-与-run-区别">start 与 run 区别</h3>

<ol>
  <li>start（） 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</li>
  <li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于<strong>就绪状态</strong>， 并没有运行。</li>
  <li>方法 run()称为线程体，它包含了要执行的这个线程的内容，<strong>线程就进入了运行状态，开始运行 run 函数当中的代码</strong>。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</li>
</ol>

<h3 id="java后台线程">Java后台线程</h3>

<ol>
  <li><strong>定义</strong>：守护线程–也称“服务线程”， 他是后台线程， 它有一个特性，即为用户线程 提供公共服务， 在没有用户线程可服务时会自动离开。</li>
  <li><strong>优先级</strong>：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务</li>
  <li><strong>设置</strong>：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建之前用线程对象的 setDaemon 方法</li>
  <li><strong>在 Daemon 线程中产生的新线程也是 Daemon 的</strong>。</li>
  <li><strong>线程则是 JVM 级别的</strong>，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，<strong>即使你停止了 Web 应用，这个线程依旧是活跃的</strong>。</li>
  <li><strong>example</strong>: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做， 所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源</li>
  <li><strong>生命周期</strong>：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候， JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</li>
</ol>

:ET