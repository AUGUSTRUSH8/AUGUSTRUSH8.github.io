I"<p>线程相关的基本方法有 wait， notify， notifyAll， sleep， join， yield 等。</p>

<p>线程的基本方法围绕着线程的状态来描述比较好理解，因此先来看一张线程状态切换图：</p>

<p><img src="http://image.augustrush8.com/images/threadState.png" alt="" class="center" /></p>

<h3 id="线程等待wait">线程等待（wait）</h3>

<p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后， <strong>会释放对象的锁</strong>。因此， wait 方法一般用在同步方法或同步代码块中。</p>

<h3 id="线程睡眠sleep">线程睡眠（sleep）</h3>

<p>sleep 导致当前线程休眠，与 wait 方法不同的是 <strong>sleep 不会释放当前占有的锁</strong>,sleep(long)会导致线程进入 <strong>TIMED-WATING</strong> 状态，而 <strong>wait()方法会导致当前线程进入 WATING 状态</strong></p>

<h3 id="线程让步yield">线程让步（yield）</h3>

<p>yield 会使当前线程<strong>让出 CPU 执行时间片</strong>，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片， 但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p>

<h3 id="线程中断interrupt">线程中断（interrupt）</h3>

<p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。 这个线程本身并不会因此而改变状态(如阻塞，终止等)。 其中有以下几点需要注意：</p>

<ul>
  <li><strong>调用 interrupt()方法并不会中断一个正在运行的线程</strong>。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</li>
  <li>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</li>
  <li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li>
  <li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部<strong>可以根据 thread.isInterrupted()的值来优雅的终止线程</strong>。</li>
</ul>

<h3 id="join-等待其他线程终止">Join 等待其他线程终止</h3>

<p><strong>join() 方法，等待其他线程终止</strong>，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p>

<h3 id="为什么要用-join方法">为什么要用 join()方法？</h3>

<p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"线程运行开始!"</span><span class="o">);</span>
    <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread6</span><span class="o">();</span>
    <span class="n">thread1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"线程 B"</span><span class="o">);</span>
    <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这时 thread1 执行完毕之后才能执行主线程"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="线程唤醒notify">线程唤醒（notify）</h3>

<p>Object 类中的 notify() 方法， <strong>唤醒在此对象监视器上等待的单个线程</strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，线程通过调用 wait() 方法，在对象的监视器上等待， <strong>直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程</strong>，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒在此监视器上等待的所有线程。</p>

<h3 id="其他方法">其他方法</h3>

<ol>
  <li>
    <p>sleep()：强迫一个线程睡眠Ｎ毫秒。</p>
  </li>
  <li>isAlive()： 判断一个线程是否存活。</li>
  <li>join()： 等待线程终止。</li>
  <li>activeCount()： 程序中活跃的线程数。</li>
  <li>enumerate()： 枚举程序中的线程。</li>
  <li>currentThread()： 得到当前线程。</li>
  <li>isDaemon()： 一个线程是否为守护线程。</li>
  <li>setDaemon()： 设置一个线程为守护线程。 (用户线程和守护线程的区别在于，是否等待主线
  程依赖于主线程结束而结束)</li>
  <li>setName()： 为线程设置一个名称。</li>
  <li>wait()： 强迫一个线程等待。</li>
</ol>

<p>11.notify()： 通知一个线程继续运行。</p>
<ol>
  <li>setPriority()： 设置一个线程的优先级。</li>
  <li>getPriority():：获得一个线程的优先级</li>
</ol>
:ET