I"!:<h3 id="深度优先搜索">深度优先搜索</h3>

<p>给定一个非负整数数组 <code class="highlighter-rouge">A</code>，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为<em>正方形</em>数组。</p>

<p>返回 A 的正方形排列的数目。两个排列 <code class="highlighter-rouge">A1</code> 和 <code class="highlighter-rouge">A2</code> 不同的充要条件是存在某个索引 <code class="highlighter-rouge">i</code>，使得 A1[i] != A2[i]。</p>

<p><strong>示例 1：</strong></p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[1,17,8]
输出：2
解释：
[1,8,17] 和 [17,8,1] 都是有效的排列。
</code></pre></div></div>

<p><strong>示例 2：</strong></p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：[2,2,2]
输出：1
</code></pre></div></div>

<h4 id="思路核心回溯">思路（核心：回溯）</h4>

<p>构造一张图，包含所有的边 i 到 j ，如果满足 A[i] + A[j] 是一个完全平方数。我们的目标就是求这张图的所有<strong>哈密尔顿路径</strong>，<strong>即经过图中所有点仅一次的路径</strong>。</p>

<h4 id="算法">算法</h4>

<p>我们使用 <code class="highlighter-rouge">count</code> 记录对于每一种值还有多少个节点等待被访问，与一个变量 <code class="highlighter-rouge">todo</code> 记录还剩多少个节点等待被访问。</p>

<h4 id="java代码实现">Java代码实现</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">numSquarefulPerms</span> <span class="o">{</span>
    <span class="c1">//定义存储数组中某个元素个数的存储结构</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span><span class="o">;</span>
    <span class="c1">//定义存储能够与某个特定元素组成完全平方数的数据集合</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSquarefulPerms</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//为全局变量分配空间</span>
        <span class="n">count</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">graph</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//求取并记录数组的大小</span>
        <span class="kt">int</span> <span class="no">N</span><span class="o">=</span><span class="no">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//遍历整个数组，统计每个元素的个数</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span><span class="no">A</span><span class="o">){</span>
            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//遍历整个数组，寻找能够与每个元素组成完全平方数的数据集</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span><span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">y:</span><span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
                <span class="kt">int</span> <span class="n">r</span><span class="o">=(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">)+</span><span class="mf">0.5</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="o">==</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">){</span>
                    <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/**
         * 开始以count keySet当中的每一个元素为根往下
         * 深度搜索能够满足条件的路径，并累加路径数
         */</span>
        <span class="c1">//先定义路径数</span>
        <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="c1">//开始搜索</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span><span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="n">ans</span><span class="o">+=</span><span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 深度优先搜索函数
     * @param  x    [description] x表示排在当前搜索的根节点
     * @param  todo [description] todo表示搜索路径的剩余节点数,它很重要，有了它算法才有收敛的可能
     * @return      [description]
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="kt">int</span> <span class="n">todo</span><span class="o">){</span>
        <span class="c1">//先把count当中对应x的值减一</span>
        <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">//定义返回结果,注意这个ans和下面那个ans定义的区别和用意</span>
        <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//开始深度搜索了</span>
        <span class="k">if</span><span class="o">(</span><span class="n">todo</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">y:</span><span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)!=</span><span class="mi">0</span><span class="o">){</span>
                    <span class="n">ans</span><span class="o">+=</span><span class="n">dfs</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">todo</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">={</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numSquarefulPerms</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="关键代码">关键代码</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
     * 深度优先搜索函数
     * @param  x    [description] x表示排在当前搜索的根节点
     * @param  todo [description] todo表示搜索路径的剩余节点数,它很重要，有了它算法才有收敛的可能
     * @return      [description]
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="kt">int</span> <span class="n">todo</span><span class="o">){</span>
        <span class="c1">//先把count当中对应x的值减一</span>
        <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
        <span class="c1">//定义返回结果,注意这个ans和下面那个ans定义的区别和用意</span>
        <span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
        <span class="c1">//开始深度搜索了</span>
        <span class="k">if</span><span class="o">(</span><span class="n">todo</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">y:</span><span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">)!=</span><span class="mi">0</span><span class="o">){</span>
                    <span class="n">ans</span><span class="o">+=</span><span class="n">dfs</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">todo</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>仔细理解上面这一段代码！</p>

<h4 id="再解释">再解释</h4>

<p>注意这其中回溯的思想的运用，类似于我需要遍历某颗多叉树，这颗多叉树的高度并不高，我可以挨个从它的子节点往下遍历，搜索每一个可能性，某一条路径走通了，就表示这条路径是可行的，一旦某个路径走不通了（没有可行解了），那么该条路径的所有其他可能子节点都可以被剪枝，不用再搜索该节点以后的其他子树了。当遍历完所有以后，统计可行路径的个数即可（当然是一边搜索一边计数咯）</p>
:ET