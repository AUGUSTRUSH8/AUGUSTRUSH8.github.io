I"<p><strong>MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？</strong></p>

<ul>
  <li>
    <p>1、varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p>
  </li>
  <li>
    <p>2、varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样，</p>

    <p>但后者在排序时会消耗更多内存，因为 <code class="highlighter-rouge">ORDER BY col</code> 采用 fixed_length 计算 col 长度(memory引擎也一样)</p>

    <blockquote>
      <p>所以，实际场景下，选择合适的 varchar 长度还是有必要的。</p>
    </blockquote>
  </li>
</ul>

<p><strong>金额(金钱)相关的数据，选择什么数据类型？</strong></p>

<ul>
  <li>方式一，使用 int 或者 bigint 类型。如果需要存储到分的维度，需要 *100 进行放大。</li>
  <li>方式二，使用 decimal 类型，避免精度丢失。如果使用 Java 语言时，需要使用 BigDecimal 进行对应。</li>
</ul>

<p><strong>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？</strong></p>

<ul>
  <li>一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。</li>
  <li>但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。</li>
</ul>

<blockquote>
  <p>生产数据，不建议进行物理删除记录。</p>
</blockquote>

<p><strong>如何选择合适的存储引擎？</strong></p>

<ol>
  <li>是否需要支持事务。</li>
  <li>对索引和缓存的支持。</li>
  <li>是否需要使用热备。</li>
  <li>崩溃恢复，能否接受崩溃。</li>
  <li>存储的限制。</li>
  <li>是否需要外键支持。</li>
</ol>

<blockquote>
  <p>目前开发已经不考虑外键，主要原因是性能</p>
</blockquote>

<p>目前，MySQL 默认的存储引擎是 InnoDB ，并且也是最主流的选择。主要原因如下：</p>

<ul>
  <li>【最重要】支持事务。</li>
  <li>支持行级锁和表级锁，能支持更多的并发量。</li>
  <li>查询不加锁，完全不影响查询。</li>
  <li>支持崩溃后恢复。</li>
</ul>

<p>在 MySQL5.1 以及之前的版本，默认的存储引擎是 MyISAM ，但是目前已经不再更新，且它有几个比较关键的缺点：</p>

<ul>
  <li>不支持事务。</li>
  <li>使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>InnoDB</th>
      <th>MyISAM</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>事务</td>
      <td>支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>存储限制</td>
      <td>64TB</td>
      <td>无</td>
    </tr>
    <tr>
      <td>锁粒度</td>
      <td>行锁</td>
      <td>表锁</td>
    </tr>
    <tr>
      <td>崩溃后的恢复</td>
      <td>支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>外键</td>
      <td>支持</td>
      <td>不支持</td>
    </tr>
    <tr>
      <td>全文检索</td>
      <td>5.7 版本后支持</td>
      <td>支持</td>
    </tr>
  </tbody>
</table>

<p><strong>为什么 SELECT COUNT() FROM table 在 InnoDB 比 MyISAM 慢？</strong></p>

<p>对于 <code class="highlighter-rouge">SELECT COUNT(*) FROM table</code> 语句，在没有 <code class="highlighter-rouge">WHERE</code> 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。</p>

<p><strong>什么是索引？</strong></p>

<p>索引，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。</p>

<p>MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。</p>

<p><strong>索引有什么好处？</strong></p>

<ol>
  <li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。</li>
  <li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。</li>
</ol>

<p><strong>索引有什么坏处？</strong></p>

<ol>
  <li>占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。</li>
  <li>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。</li>
</ol>

<p><strong>索引的使用场景？</strong></p>

<ul>
  <li>1、对非常小的表，大部分情况下全表扫描效率更高。</li>
  <li>2、对中大型表，索引非常有效。</li>
  <li>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</li>
</ul>

<blockquote>
  <p>实际场景下，MySQL 分区表很少使用,对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p>
</blockquote>

<p><strong>索引的类型？</strong></p>

<p>索引，都是实现在存储引擎层的。主要有六种类型：</p>

<ul>
  <li>1、普通索引：最基本的索引，没有任何约束。</li>
  <li>2、唯一索引：与普通索引类似，但具有唯一性约束。</li>
  <li>3、主键索引：特殊的唯一索引，不允许有空值。</li>
  <li>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</li>
  <li>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</li>
  <li>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</li>
</ul>

<blockquote>
  <p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。</p>
</blockquote>

<p><strong>MySQL 索引的“创建”原则？</strong></p>

<ul>
  <li>1、最适合索引的列是出现在 <code class="highlighter-rouge">WHERE</code> 子句中的列，或连接子句中的列，而不是出现在 <code class="highlighter-rouge">SELECT</code> 关键字后的列。</li>
  <li>2、索引列的基数越大，索引效果越好。</li>
  <li>3、根据情况创建复合索引，复合索引可以提高查询效率。</li>
</ul>

<blockquote>
  <p>因为复合索引的基数会更大。</p>
</blockquote>

<ul>
  <li>
    <p>4、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>
  </li>
  <li>5、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。</li>
  <li>6、对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。</li>
</ul>

<p><strong>MySQL 索引的“使用”注意事项？</strong></p>

<ul>
  <li>1、应尽量避免在 <code class="highlighter-rouge">WHERE</code> 子句中使用 <code class="highlighter-rouge">!=</code> 或 <code class="highlighter-rouge">&lt;&gt;</code> 操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</li>
</ul>

<blockquote>
  <p>注意，<code class="highlighter-rouge">column IS NULL</code> 也是不可以使用索引的。</p>
</blockquote>

<ul>
  <li>2、应尽量避免在 <code class="highlighter-rouge">WHERE</code> 子句中使用 <code class="highlighter-rouge">OR</code> 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<code class="highlighter-rouge">SELECT id FROM t WHERE num = 10 OR num = 20</code> 。</li>
  <li>3、应尽量避免在 <code class="highlighter-rouge">WHERE</code> 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
  <li>4、应尽量避免在 <code class="highlighter-rouge">WHERE</code> 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li>
  <li>5、不要在 <code class="highlighter-rouge">WHERE</code> 子句中的 <code class="highlighter-rouge">=</code> 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
  <li>6、复合索引遵循前缀原则。</li>
  <li>7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。</li>
  <li>8、列类型是字符串类型，查询时一定要给值加引号，否则索引失效。</li>
  <li>9、<code class="highlighter-rouge">LIKE</code> 查询，<code class="highlighter-rouge">%</code> 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。</li>
</ul>

<p><strong>以下三条 SQL 如何建索引，只建一条怎么建？</strong></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WHERE</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">time</span> <span class="k">DESC</span>
</code></pre></div></div>

<ul>
  <li>以顺序 b , a, time 建立复合索引，<code class="highlighter-rouge">CREATE INDEX table1_b_a_time ON index_test01(b, a, time)</code>。</li>
  <li>对于第一条 SQL ，因为最新 MySQL 版本会优化 <code class="highlighter-rouge">WHERE</code> 子句后面的列顺序，以匹配复合索引顺序。</li>
</ul>

<p><strong>想知道一个查询用到了哪个索引，如何查看?</strong></p>

<p><code class="highlighter-rouge">EXPLAIN</code> 显示了 MYSQL 如何使用索引来处理 SELECT 语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句。</p>

<p>使用方法，在 <code class="highlighter-rouge">SELECT</code> 语句前加上 <code class="highlighter-rouge">EXPLAIN</code> 就可以了。</p>

<p><strong>MySQL 有哪些索引方法？</strong></p>

<p>在 MySQL 中，我们可以看到两种索引方式：</p>

<ul>
  <li>B-Tree 索引。</li>
  <li>Hash 索引。</li>
</ul>

<p>实际场景下，我们基本仅仅使用 B-Tree 索引。</p>

<p><strong>什么是 B-Tree 索引？</strong></p>

<p>B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 B-Tree 之前先了解下磁盘的相关知识。</p>

<ul>
  <li>
    <p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
  </li>
  <li>
    <p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K ，在 MySQL 中可通过如下命令查看页的大小：</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">'innodb_page_size'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p>
  </li>
</ul>

<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>

<p>一棵 m 阶的 B-Tree 有如下特性：</p>

<ol>
  <li>每个节点最多有 m 个孩子。
    <ul>
      <li>除了根节点和叶子节点外，其它每个节点至少有 Ceil(m/2) 个孩子。</li>
      <li>若根节点不是叶子节点，则至少有 2 个孩子。</li>
    </ul>
  </li>
  <li>所有叶子节点都在同一层，且不包含其它关键字信息。</li>
  <li>每个非叶子节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）
    <ul>
      <li>关键字的个数 n 满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
      <li>ki(i=1,…n) 为关键字，且关键字升序排序。</li>
      <li>Pi(i=0,…n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki ，但都大于 k(i-1) 。</li>
    </ul>
  </li>
</ol>

<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>

<p><img src="http://image.augustrush8.com/images/mysql1.png" alt="" class="center" /></p>

<ul>
  <li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，point 存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。</li>
  <li>以根节点为例，key 为 17 和 35 ，P1 指针指向的子树的数据范围为小于 17 ，P2 指针指向的子树的数据范围为 [17~35] ，P3 指针指向的子树的数据范围为大于 35 。</li>
</ul>

<p>模拟查找 key 为 29 的过程：</p>

<ul>
  <li>1、根据根节点找到磁盘块 1 ，读入内存。【磁盘I/O操作第1次】</li>
  <li>2、比较 key 29 在区间（17,35），找到磁盘块 1 的指针 P2 。</li>
  <li>3、根据 P2 指针找到磁盘块 3 ，读入内存。【磁盘I/O操作第2次】</li>
  <li>4、比较 key 29 在区间（26,30），找到磁盘块3的指针P2。</li>
  <li>5、根据 P2 指针找到磁盘块 8 ，读入内存。【磁盘I/O操作第3次】</li>
  <li>6、在磁盘块 8 中的 key 列表中找到 eky 29 。</li>
</ul>

<p>分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>

<p><strong>什么是 B+Tree 索引？</strong></p>

<p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。</p>

<blockquote>
  <p>下面这一段，非常关键。</p>
</blockquote>

<p>从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>

<p>B+Tree 相对于 B-Tree 有几点不同：</p>

<ul>
  <li>非叶子节点只存储键值信息。</li>
  <li>所有叶子节点之间都有一个链指针。</li>
  <li>数据记录都存放在叶子节点中。</li>
</ul>

<p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p>

<p><img src="http://image.augustrush8.com/images/mysql2.png" alt="" class="center" /></p>

<ul>
  <li>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
</ul>

<p>可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：</p>

<ul>
  <li>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</li>
  <li>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。</li>
</ul>

<p><strong>B+Tree 有哪些索引类型？</strong></p>

<p>在 B+Tree 中，根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p>

<ul>
  <li>
    <p>主键索引的叶子节点存的数据是整行数据( 即具体数据 )。在 InnoDB 里，主键索引也被称为<strong>聚集索引</strong>（clustered index）。</p>
  </li>
  <li>
    <p>非主键索引的叶子节点存的数据是整行数据的主键，键值是索引。在 InnoDB 里，非主键索引也被称为</p>

    <p>辅助索引</p>

    <p>（secondary index）。</p>

    <blockquote>
      <p>二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
    </blockquote>
  </li>
</ul>

<p>辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，需要进过两步：</p>

<ul>
  <li>首先，InnoDB 存储引擎会遍历辅助索引找到主键。</li>
  <li>然后，再通过主键在聚集索引中找到完整的行记录数据。</li>
</ul>

<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。</p>

<p><strong>聚簇索引的注意点有哪些？</strong></p>

<p>聚簇索引表最大限度地提高了 I/O 密集型应用的性能，但它也有以下几个限制：</p>

<ul>
  <li>
    <p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
  </li>
  <li>
    <p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>

    <blockquote>
      <p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
    </blockquote>
  </li>
  <li>
    <p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>

    <blockquote>
      <p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
    </blockquote>
  </li>
  <li>
    <p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
  </li>
</ul>

<p><strong>什么是索引的最左匹配特性？</strong></p>

<p>当 B+Tree 的数据项是复合的数据结构，比如索引 <code class="highlighter-rouge">(name, age, sex)</code> 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。</p>

<ul>
  <li>比如当 <code class="highlighter-rouge">(张三, 20, F)</code> 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。</li>
  <li>但当 <code class="highlighter-rouge">(20, F)</code> 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</li>
  <li>比如当 <code class="highlighter-rouge">(张三, F)</code> 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。</li>
</ul>

<p>这个是非常重要的性质，即索引的最左匹配特性。</p>

<p><strong>MyISAM 索引实现？</strong></p>

<p>MyISAM 索引的实现，和 InnoDB 索引的实现是一样使用 B+Tree ，<strong>差别在于 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</strong>。</p>

<p>1）主键索引：</p>

<p>MyISAM引 擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p>

<p><img src="http://image.augustrush8.com/images/mysql3.png" alt="" class="center" /></p>

<ul>
  <li>这里设表一共有三列，假设我们以 Col1 为主键，上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。</li>
</ul>

<p>2）辅助索引：</p>

<p><strong>在 MyISAM 中，主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。</strong>如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：</p>

<p><img src="http://image.augustrush8.com/images/mysql4.png" alt="" class="center" /></p>

<ul>
  <li>同样也是一颗 B+Tree ，data 域保存数据记录的地址。因此，<strong>MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</strong></li>
</ul>

<p>MyISAM 的索引方式也叫做“<strong>非聚集</strong>”的，之所以这么称呼是为了与InnoDB 的聚集索引区分。</p>

<p><strong>MyISAM 索引与 InnoDB 索引的区别？</strong></p>

<ul>
  <li>
    <p>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</p>
  </li>
  <li>
    <p>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</p>
  </li>
  <li>
    <p>MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</p>
  </li>
  <li>
    <p>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p>

    <blockquote>
      <p>覆盖索引，指的是基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
    </blockquote>
  </li>
</ul>

<p><strong>MySQL 的四种事务隔离级别</strong></p>

<p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>

<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>

<p><strong>事务的特性指的是？</strong></p>

<p><img src="http://image.augustrush8.com/images/mysql5.png" alt="" class="center" /></p>

<ol>
  <li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
  <li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&amp;action=edit&amp;redlink=1">级联回滚</a>等。</li>
  <li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
  <li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>

<p><strong>事务的并发问题？</strong></p>

<p>实际场景下，事务并不是串行的，所以会带来如下三个问题：</p>

<ul>
  <li>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>
  <li>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
  <li>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>

<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>

<p><strong>MySQL 事务隔离级别会产生的并发问题？</strong></p>

<p>事务定义了四种事务隔离级别，不同数据库在实现时，产生的并发问题是不同的。</p>

<blockquote>
  <p>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。</p>
</blockquote>

<ul>
  <li>
    <p>READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。</p>

    <blockquote>
      <p>会导致脏读。</p>
    </blockquote>
  </li>
  <li>
    <p>READ COMMITTED（提交读）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。</p>

    <blockquote>
      <p>会导致不可重复读。</p>

      <p>这个隔离级别，也可以叫做“不可重复读”。</p>
    </blockquote>
  </li>
  <li>
    <p>REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。</p>

    <blockquote>
      <p>会导致幻读。</p>
    </blockquote>
  </li>
  <li>
    <p>SERIALIZABLE（可串行化）：强制事务串行执行。</p>
  </li>
</ul>

<p>MySQL InnoDB 采用 <strong>MVCC</strong> 来支持高并发，实现结果如下表所示：</p>

<table>
  <thead>
    <tr>
      <th>事务隔离级别</th>
      <th>脏读</th>
      <th>不可重复读</th>
      <th>幻读</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>读未提交（read-uncommitted）</td>
      <td>是</td>
      <td>是</td>
      <td>是</td>
    </tr>
    <tr>
      <td>读已提交（read-committed）</td>
      <td>否</td>
      <td>是</td>
      <td>是</td>
    </tr>
    <tr>
      <td>可重复读（repeatable-read）</td>
      <td>否</td>
      <td>否</td>
      <td>是（x）</td>
    </tr>
    <tr>
      <td>串行化（serializable）</td>
      <td>否</td>
      <td>否</td>
      <td>否</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>MySQL 默认的事务隔离级别为可重复读（repeatable-read） 。</li>
  <li>上图的 <code class="highlighter-rouge">&lt;X&gt;</code> 处，MySQL 因为其间隙锁的特性，导致其在可重复读（repeatable-read）的隔离级别下，不存在幻读问题。也就是说，上图 <code class="highlighter-rouge">&lt;X&gt;</code> 处，需要改成“否”！！！！</li>
  <li>有些资料说可重复读解决了幻读，实际是存在的，可以通过 <code class="highlighter-rouge">SELECT xxx FROM t WHERE id = ? FOR UPDATE</code> 的方式，获得到悲观锁，禁止其它事务操作对应的数据，从而解决幻读问题。</li>
</ul>

<blockquote>
  <p>其实 RR 也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id = 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。</p>
</blockquote>

<p><strong>MySQL 的锁机制</strong></p>

<p>MySQL 的共享锁和排他锁，就是读锁和写锁。</p>

<ul>
  <li>共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。</li>
  <li>排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。</li>
</ul>

<p><strong>锁的粒度？</strong></p>

<ul>
  <li>表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。</li>
  <li>行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。</li>
</ul>

<p><strong>什么是悲观锁？什么是乐观锁？</strong></p>

<p>1）悲观锁</p>

<p>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>

<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>

<p>2）乐观锁</p>

<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>

<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>

<blockquote>
  <p>乐观锁，实际就是通过版本号，从而实现 CAS 原子性更新。</p>
</blockquote>

<p><strong>什么是死锁？</strong></p>

<p>多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁。</p>

<p>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：</p>

<ul>
  <li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
  <li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
  <li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
  <li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，•••，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>

<p>下列方法有助于最大限度地降低死锁：</p>

<ul>
  <li>
    <p>设置获得锁的超时时间。</p>

    <blockquote>
      <p>通过超时，至少保证最差最差最差情况下，可以有退出的口子。</p>
    </blockquote>
  </li>
  <li>
    <p>按同一顺序访问对象。</p>

    <blockquote>
      <p>这个是最重要的方式。</p>
    </blockquote>
  </li>
  <li>
    <p>避免事务中的用户交互。</p>
  </li>
  <li>
    <p>保持事务简短并在一个批处理中。</p>
  </li>
  <li>
    <p>使用低隔离级别。</p>
  </li>
  <li>
    <p>使用绑定连接。</p>
  </li>
</ul>

<p><strong>MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？</strong></p>

<p><strong>InnoDB 是基于索引来完成行锁</strong>。例如：<code class="highlighter-rouge">SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE</code> 。</p>

<ul>
  <li><code class="highlighter-rouge">FOR UPDATE</code> 可以根据条件来完成<strong>行锁</strong>锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成<strong>表锁</strong>，并发将无从谈起。</li>
</ul>

<p><strong>MySQL 查询执行顺序</strong></p>

<p>MySQL 查询执行的顺序是：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="k">SELECT</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span>     <span class="k">DISTINCT</span> <span class="o">&lt;</span><span class="n">select_list</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="k">FROM</span> <span class="o">&lt;</span><span class="n">left_table</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span>     <span class="o">&lt;</span><span class="n">join_type</span><span class="o">&gt;</span> <span class="k">JOIN</span> <span class="o">&lt;</span><span class="n">right_table</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">5</span><span class="p">)</span>     <span class="k">ON</span> <span class="o">&lt;</span><span class="n">join_condition</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">6</span><span class="p">)</span>     <span class="k">WHERE</span> <span class="o">&lt;</span><span class="n">where_condition</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span>     <span class="k">GROUP</span> <span class="k">BY</span> <span class="o">&lt;</span><span class="n">group_by_list</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">8</span><span class="p">)</span>     <span class="k">HAVING</span> <span class="o">&lt;</span><span class="n">having_condition</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">9</span><span class="p">)</span>     <span class="k">ORDER</span> <span class="k">BY</span> <span class="o">&lt;</span><span class="n">order_by_condition</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">10</span><span class="p">)</span>    <span class="k">LIMIT</span> <span class="o">&lt;</span><span class="n">limit_number</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><strong>什么是 MVCC ？</strong></p>

<p>多版本并发控制（MVCC），是一种用来<strong>解决读-写冲突</strong>的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
:ET