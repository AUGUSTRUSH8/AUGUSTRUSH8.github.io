I"<h3 id="需求描述">需求描述</h3>

<p>有40亿个整数，再给一个新的整数，需要判断新的整数是否在40亿个整数中，你会怎么做？</p>

<h3 id="解决方案">解决方案</h3>

<ul>
  <li>不假思索的解决方案–40亿个数放在Set当中，然后看是否存在</li>
</ul>

<p>思考：整数32位，这个存储整数的Set需要多大？</p>

<p>一个整数4个字节，40亿个整数160亿字节，将近16G的内存</p>

<p>问题是，如果我只有2G的内存，该怎么办呢？</p>

<p>分8次加载？那样的话会很慢的，从磁盘加载数据是磁盘io操作，是非常慢的，每次都要加载这么大的数据，还要8次，估计找一个数的时间可以达到分钟甚至小时级了。</p>

<p><img src="http://image.augustrush8.com/images/findnum1.png" alt="" class="center" /></p>

<ul>
  <li>稍好一点的解决方案，分批放在8台机器上，按分布式的思路解决这个问题</li>
</ul>

<p><img src="http://image.augustrush8.com/images/findnum2.png" alt="" class="center" /></p>

<p>8台机器分别计算，最终汇总结果，一次性读入数据，查找很快。</p>

<p>这样做的话，因为每台机器都可以一次性把数据读入内存，在比较的时候不用来回加载数据了，所以可以节省加载数据的开销。</p>

<ul>
  <li>毫秒级的解决方案–bitmap</li>
</ul>

<p>32位int的范围，总共就是2的32次方，大概42亿多点。所以可以申请2的32次方个位。把整个整数范围都覆盖了。</p>

<p>1代表第一个位，2代表第二个位，2的32次方代表最后一个位。40亿个数中，存在的数就在相应的位置1，其他位就是0。</p>

<p><img src="http://image.augustrush8.com/images/findnum3.png" alt="" class="center" /></p>

<p>比如来了一个新的数1234，就找一下第1234位，如果是1就存在，是0就不存在。</p>

<p>这样的话，需要多大内存呢？</p>

<blockquote>
  <p>2的32次方个位，相当于2的29次方个字节，500多MB，节省了不少内存。</p>
</blockquote>

<ul>
  <li>另外一张优秀的解决方案–自创数据结构存储</li>
</ul>

<p>思考一下，32位int的范围是42亿，40亿整数中肯定有一些是连续的，可以先对数据进行一个外部排序，然后用一个<strong>初始的数</strong>和一个<strong>长度</strong>构成一个数据结构，来表示一段连续的数，举例：</p>

<p>如果数据是1 2 3 4 6 7……这种的，那么可以用(1,4)和(6,2)来表示，这样一来，连续的数都变成了2个数表示。</p>

<p>来了一个新数之后，就用<strong>二分法进行查找</strong>了。</p>

<p>这样一来，最差情况就是2亿多的断点，也就是2亿多的结构体，每个结构体8个字节，大概16亿字节，1.6GB，在内存中可以放下。</p>

<p><img src="http://image.augustrush8.com/images/findnum4.png" alt="" class="center" /></p>

:ET