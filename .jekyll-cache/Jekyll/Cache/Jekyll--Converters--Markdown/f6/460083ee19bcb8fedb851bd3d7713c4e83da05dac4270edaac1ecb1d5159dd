I"W?<p>Java里面的异常在真正工作中使用还是十分普遍的。什么时候该抛出什么异常，这个是必须知道的。</p>

<h3 id="checked异常和unchecked异常">checked异常和unchecked异常</h3>

<ul>
  <li><strong>checked异常</strong></li>
</ul>

<p>表示无效，不是程序中可以预测的。比如无效的用户输入，文件不存在，网络或者数据库链接错误。这些都是<strong>外在的原因</strong>，都不是程序内部可以控制的。</p>

<p>必须在代码中显式地处理。比如try-catch块处理，或者给所在的方法加上throws说明，将异常抛到调用栈的上一层。继承自java.lang.Exception（java.lang.RuntimeException除外）。</p>

<ul>
  <li><strong>unchecked异常：</strong></li>
</ul>

<p><strong>表示错误，程序的逻辑错误</strong>。是RuntimeException的子类，比如IllegalArgumentException, NullPointerException和IllegalStateException。</p>

<p><strong>不需要在代码中显式地捕获unchecked异常做处理</strong>。</p>

<p>继承自java.lang.RuntimeException（而java.lang.RuntimeException继承自java.lang.Exception）。</p>

<p>看张图：</p>

<p><img src="http://image.augustrush8.com/images/javaexception.png" alt="" class="center" /></p>

<h3 id="异常封装实例">异常封装实例</h3>

<ul>
  <li><strong>添加一个枚举LuoErrorCode.java如下：</strong></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">package</span> <span class="nx">com</span><span class="p">.</span><span class="nx">luo</span><span class="p">.</span><span class="nx">errorcode</span><span class="p">;</span>

<span class="kr">public</span> <span class="kr">enum</span> <span class="nx">LuoErrorCode</span> <span class="p">{</span>

    <span class="nx">NULL_OBJ</span><span class="p">(</span><span class="dl">"</span><span class="s2">LUO001</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">对象为空</span><span class="dl">"</span><span class="p">),</span>
    <span class="nx">ERROR_ADD_USER</span><span class="p">(</span><span class="dl">"</span><span class="s2">LUO002</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">添加用户失败</span><span class="dl">"</span><span class="p">),</span>
    <span class="nx">UNKNOWN_ERROR</span><span class="p">(</span><span class="dl">"</span><span class="s2">LUO999</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">系统繁忙，请稍后再试....</span><span class="dl">"</span><span class="p">);</span>

    <span class="kr">private</span> <span class="nb">String</span> <span class="nx">value</span><span class="p">;</span>
    <span class="kr">private</span> <span class="nb">String</span> <span class="nx">desc</span><span class="p">;</span>

    <span class="kr">private</span> <span class="nx">LuoErrorCode</span><span class="p">(</span><span class="nb">String</span> <span class="nx">value</span><span class="p">,</span> <span class="nb">String</span> <span class="nx">desc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setValue</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setDesc</span><span class="p">(</span><span class="nx">desc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">getValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="k">void</span> <span class="nx">setValue</span><span class="p">(</span><span class="nb">String</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">getDesc</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">desc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="k">void</span> <span class="nx">setDesc</span><span class="p">(</span><span class="nb">String</span> <span class="nx">desc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">desc</span> <span class="o">=</span> <span class="nx">desc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">@</span><span class="nd">Override</span>
    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">toString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">desc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里重写了LuoErrorCode的toString方法，后面会看到为什么</p>

<ul>
  <li><strong>创建一个异常类BusinessException.java，继承RuntimeException</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">luo</span><span class="o">.</span><span class="na">exception</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BusinessException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BusinessException</span><span class="o">(</span><span class="nc">Object</span> <span class="nc">Obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">Obj</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>注意两点：</p>

<ol>
  <li><strong>其继承了RuntimeException，因为一般我们的业务异常都是运行时异常</strong></li>
  <li><strong>这里的构造方法调用父方法super(Obj.toString());，这就是重写了LuoErrorCode的toString方法的原因了</strong></li>
</ol>

<ul>
  <li><strong>编写测试类ExceptionTest.java</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">luo</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.luo.errorcode.LuoErrorCode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.luo.exception.BusinessException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExceptionTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">user</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BusinessException</span><span class="o">(</span><span class="nc">LuoErrorCode</span><span class="o">.</span><span class="na">NULL_OBJ</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="http://image.augustrush8.com/images/javaexception1.png" alt="" class="center" /></p>

<h3 id="总结">总结</h3>

<p>在我们实际项目里面，比如别人调用你接口，你可能需要先看他传过来的对象是不是空的，先判断如果传过来的对象为空会有友好的提示”[LUO001]对象为空”，不然后面的代码就会出现空指针异常了。</p>

<h3 id="拓展">拓展</h3>

<ul>
  <li><strong>Error和Exception的联系</strong></li>
</ul>

<p>继承结构：Error和Exception都是继承于Throwable，RuntimeException继承自Exception。</p>

<p>Error和RuntimeException及其子类称为未检查异常（Unchecked exception），其它异常成为受检查异常（Checked Exception）。</p>

<ul>
  <li><strong>Error和Exception的区别</strong></li>
</ul>

<p>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError。对于这类错误，Java编译器不去检查他们。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。</p>

<p>Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>

<ul>
  <li><strong>运行时异常和受检查的异常</strong></li>
</ul>

<p>Exception又分为运行时异常（Runtime Exception）和受检查的异常(Checked Exception )。</p>

<p>RuntimeException：其特点是Java编译器不去检查它，也就是说，当程序中可能出现这类异常时，即使没有用try……catch捕获，也没有用throws抛出，还是会编译通过，如除数为零的ArithmeticException、错误的类型转换、数组越界访问和试图访问空指针等。处理RuntimeException的原则是：如果出现RuntimeException，那么一定是程序员的错误。</p>

<p>受检查的异常（IOException等）：这类异常如果没有try……catch也没有throws抛出，编译是通不过的。这类异常一般是外部错误，例如文件找不到、试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。</p>

<ul>
  <li><strong>throw 和 throws两个关键字有什么不同</strong></li>
</ul>

<p>throw 是用来抛出任意异常的，你可以抛出任意 Throwable，包括自定义的异常类对象；throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。如果方法抛出了异常，那么调用这个方法的时候就需要处理这个异常。</p>

<ul>
  <li><strong>try-catch-finally-return执行顺序</strong></li>
</ul>

<p>1、不管是否有异常产生，finally块中代码都会执行；
2、当try和catch中有return语句时，finally块仍然会执行；
3、finally是在return后面的表达式运算后执行的，所以函数返回值是在finally执行前确定的。无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值；</p>

<p>4、<strong>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</strong>。</p>

<p>举例：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>情况1：try{} catch(){}finally{} return; 
按正常顺序执行。

情况2：try{ return; }catch(){} finally{} return; 
程序执行try块中return之前（包括return语句中的表达式运算）代码； 
再执行finally块，最后执行try中return; 
finally块后面的return语句不再执行。

情况3：try{ } catch(){return;} finally{} return; 
程序先执行try，如果遇到异常执行catch块， 
有异常： 
则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码， 
最后执行catch块中return. finally块后面的return语句不再执行。 
无异常： 
执行完try再finally再执行最后的return语句.

情况4：try{ return; }catch(){} finally{return;} 
程序执行try块中return之前（包括return语句中的表达式运算）代码； 
再执行finally块，因为finally块中有return所以提前退出。

情况5：try{} catch(){return;}finally{return;} 
程序执行catch块中return之前（包括return语句中的表达式运算）代码； 
再执行finally块，因为finally块中有return所以提前退出。

情况6：try{ return;}catch(){return;} finally{return;} 
程序执行try块中return之前（包括return语句中的表达式运算）代码； 
有异常：执行catch块中return之前（包括return语句中的表达式运算）代码； 
则再执行finally块，因为finally块中有return所以提前退出。 
无异常：则再执行finally块，因为finally块中有return所以提前退出。

</code></pre></div></div>

<p>测试程序实例</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FinallyTest</span>  
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">FinallyTest</span><span class="o">().</span><span class="na">test</span><span class="o">());;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="n">x</span><span class="o">++;</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">finally</span>
        <span class="o">{</span>
            <span class="o">++</span><span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>打印结果是2。</p>

<blockquote>
  <p>根据之前的分析，在try语句块中，在执行return语句时，要返回的结果已经准备好了，然后程序转到finally执行。在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，再从中取出返回结果，因此，即使finally中对变量x进行了改变，也不会影响返回结果。</p>
</blockquote>

:ET