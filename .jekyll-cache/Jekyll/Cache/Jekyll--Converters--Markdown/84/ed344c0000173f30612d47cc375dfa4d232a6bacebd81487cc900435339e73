I"v<h3 id="四次挥手">四次挥手</h3>

<p><img src="http://image.augustrush8.com/images/timeout1.png" alt="" class="center" /></p>

<ul>
  <li>
    <p>第一次：主机1（<strong>可以是客户端，也可以是服务器端</strong>），设置<strong>Sequence Number</strong>，向主机2发送一个<strong>FIN</strong>报文段；此时，主机1进入<strong>FIN_WAIT_1</strong>状态；这表示主机1没有数据要发送给主机2了；</p>
  </li>
  <li>第二次：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，<strong>Acknowledgment Number</strong>为<strong>Sequence Numbe</strong><strong>r加1</strong>；主机1进入<strong>FIN_WAIT_2</strong>状态；主机2告诉主机1，我“同意”你的关闭请求；</li>
  <li>第三次：主机2向主机1发送<strong>FIN</strong>报文段，请求关闭连接，同时主机2进入<strong>LAST_ACK</strong>状态；</li>
  <li>第四次：主机1收到主机2发送的<strong>FIN</strong>报文段，向主机2发送<strong>ACK</strong>报文段，然后主机1进入<strong>TIME_WAIT</strong>状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ul>

<p><strong>解释</strong>：<strong>MSL</strong>是指Max Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为<strong>1-4分钟。</strong></p>

<h3 id="四次挥手过程中通信双方状态解析">四次挥手过程中通信双方状态解析</h3>

<ul>
  <li><strong>FIN_WAIT_1:</strong> 其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li>
  <li>
    <p><strong>FIN_WAIT_2</strong>：实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外一方告诉主动方，我暂时还有点数据需要传送给你，稍后再关闭连接。（主动方）</p>
  </li>
  <li>
    <p><strong>CLOSE_WAIT</strong>：表示在等待关闭。当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是查看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p>
  </li>
  <li><strong>LAST_ACK:</strong> 被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li>
  <li><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN WAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li>
  <li><strong>CLOSED:</strong> 表示连接中断。</li>
</ul>

<h3 id="为什么要有time_wait这个状态">为什么要有TIME_WAIT这个状态</h3>

<ul>
  <li>第一，防止前一个连接上延迟的数据包或者丢失重传的数据包，被后面<strong>复用的连接</strong>错误的接收，那这个新收到的包究竟是这个新连接产生的呢，还是上一次连接产生的呢</li>
  <li>第二，确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的
    <ul>
      <li>主动关闭方关闭了连接，发送了FIN；</li>
      <li>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态</li>
      <li>主动关闭的一方回复了ACK，主动关闭一方进入TIME_WAIT状态；</li>
      <li>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态</li>
      <li>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST</li>
      <li>造成主动创建连接的一方，由于收到了RST，则连接无法成功</li>
    </ul>
  </li>
</ul>

<p>所以，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成<strong>数据粗乱</strong>，或者<strong>短暂性的连接失败</strong>。</p>

<h3 id="出现太多time_wait可能导致的后果">出现太多TIME_WAIT可能导致的后果</h3>

<p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。
来解释下这个场景。主动正常关闭TCP连接，都会出现TIMEWAIT。为什么我们要关注这个高并发短连接呢？有两个方面需要注意：</p>

<ul>
  <li>高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</li>
  <li>在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高）</li>
</ul>

<p>综合这两个方面，<strong>持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。</strong></p>

<h3 id="time_wait太多怎么解决"><strong>TIME_WAIT太多怎么解决</strong></h3>

<p>修改/etc/sysctl.conf ：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> net.ipv4.tcp_tw_reuse = 1  #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

   net.ipv4.tcp_tw_recycle = 1   #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_timestamps 开启时，net.ipv4.tcp_tw_recycle开启才能生效,。

   net.ipv4.tcp_timestamps = 1     #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

   net.ipv4.tcp_fin_timeout = 2      #用来设置保持在FIN_WAIT_2状态的时间

</code></pre></div></div>

<p>保存后sysctl -p生效</p>
:ET